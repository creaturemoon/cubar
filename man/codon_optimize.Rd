% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{codon_optimize}
\alias{codon_optimize}
\title{Optimize codons}
\usage{
codon_optimize(
  seq,
  optimal_codons = optimal_codons,
  cf = NULL,
  codon_table = get_codon_table(),
  level = "subfam",
  method = "naive",
  num_sequences = 1,
  organism = NULL,
  envname = "cubar_env",
  attention_type = "original_full",
  deterministic = TRUE,
  temperature = 0.2,
  top_p = 0.95,
  match_protein = FALSE,
  spliceai = FALSE
)
}
\arguments{
\item{seq}{DNAString, or an object that can be coerced to a DNAString.}

\item{optimal_codons}{table optimze codons as generated by \code{est_optimal_codons}.}

\item{cf}{matrix of codon frequencies as calculated by \code{count_codons()}. Required when method is set to "IDT".}

\item{codon_table}{a table of genetic code derived from \code{get_codon_table} or
\code{create_codon_table}.}

\item{level}{"subfam" (default) or "amino_acid". Optimize codon usage at which level.
Required when method is set to "naive" or "IDT".}

\item{method}{"naive" (default), "IDT" or "CodonTransformer". For which method to estimate optimal codons.
The "IDT" method derives from the Codon Optimization Tool of INTEGRATED DNA TECHNOLOGIES. 
The "CodonTransformer" method derives from the tool CodonTransformer.}

\item{num_sequences}{number of different DNA sequences to generate. Default is 1. Required when method is 
set to "IDT" or "CodonTransformer". When greater than 1, identical duplicate sequences will be retained 
as a single copy, potentially resulting in a final sequence count that is less than the specified value.
With the method "CodonTransformer", only works when deterministic=False, and each sequence will be sampled 
based on the temperature and top_p parameters.}

\item{organism}{organism ID (integer) or name (string) (e.g., "Escherichia coli general", 
must be from ORGANISM2ID in CodonUtils). Required when method is set to "CodonTransformer".}

\item{envname}{the name of an environment when using the method "CodonTransformer" or when "spliceai" is TRUE.
Maintain consistency with user-defined conda environment name.}

\item{attention_type}{type of attention mechanism to use in model - 'block_sparse' for memory efficient
or 'original_full' (default) for standard attention. Required when method is set to "CodonTransformer".}

\item{deterministic}{if TRUE (default), uses deterministic decoding (picks most likely tokens). 
If "False", samples tokens based on probabilities adjusted by temperature.
Required when method is set to "CodonTransformer".}

\item{temperature}{controls randomness in non-deterministic mode. Lower values (0.2) are conservative and 
pick high probability tokens, while higher values (0.8) allow more diversity.
Must be positive. Required when method is set to "CodonTransformer". Default is 0.2.}

\item{top_p}{nucleus sampling threshold - only tokens with cumulative probability up to this value are considered.
Balances diversity and quality of predictions. Must be between 0 and 1.
Required when method is set to "CodonTransformer". Default is 0.95.}

\item{match_protein}{constrains predictions to only use codons that translate back to the exact input protein sequence.
Only recommended when using high temperatures or error prone input proteins
(e.g. not starting with methionine or having numerous repetitions). Default is FALSE.}

\item{spliceai}{TRUE or FALSE (default). whether to run spliceai to predict possible splice junction sites.
This option derives from the tool SpliceAI.}
}
\value{
a DNAString of the optimized coding sequence when num_sequences is set to 1 and spliceai is FALSE,
or a DNAStringSet of the optimized coding sequences when num_sequences is large than 1 and spliceai is FALSE,
or a data.table object, including columns of candidate optimized sequences and columns indicating
the possibility of splice sites when spliceai is TRUE.
}
\description{
\code{codon_optimize} takes a coding sequence (without stop codon) and replace
each codon to the corresponding synonymous optimal codon.
}
\examples{
cf_all <- count_codons(yeast_cds)
optimal_codons <- est_optimal_codons(cf_all)
seq <- 'ATGCTACGA'
# method "naive":
codon_optimize(seq, optimal_codons)
# method "IDT":
codon_optimize(seq, cf = cf_all, method = "IDT")
codon_optimize(seq, cf = cf_all, method = "IDT", num_sequences = 10)
# method "CodonTransformer":
seq_opt <- codon_optimize(seq, method = "CodonTransformer", organism = "Saccharomyces cerevisiae")
print(seq_opt)
seqs_opt <- codon_optimize(seq, method = "CodonTransformer", organism = "Saccharomyces cerevisiae",
num_sequences = 10, deterministic =FALSE, temperature = 0.4)
print(seqs_opt)
seqs_opt <- codon_optimize(seq, cf = cf_all, method = "IDT", num_sequences = 10, spliceai = TRUE)
print(seqs_opt)
seq_opt <- codon_optimize(seq, method = "CodonTransformer", organism = "Saccharomyces cerevisiae",
spliceai = TRUE)
print(seq_opt)
}
\references{
Fallahpour A, Gureghian V, Filion GJ, Lindner AB, Pandi A. CodonTransformer: 
a multispecies codon optimizer using context-aware neural networks. Nat Commun. 2025 Apr 3;16(1):3205.

Jaganathan K, Panagiotopoulou S K, McRae J F, et al. Predicting splicing from primary sequence
 with deep learning[J].Cell, 2019, 176(3): 535-548. e24.
}
